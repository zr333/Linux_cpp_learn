# 死锁的定义：
死锁，是指多个线程或者进程在运行过程中因争夺资源而造成的一种僵局，当进程或者线程处于这种僵持状态，若无外力作用，它们将无法再向前推进。
申请锁资源为例。线程 A 想申请线程 B 的锁，线程 B 想申请线程 C 的锁，线程 C 想申请线程 D 的锁，线程 D 想申请线程 A 的锁，从而构建了一个资源申请环。
# 死锁产生的条件
1.条件互斥：线程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程/线程所占用。
2.持有并等待条件：线程在占有资源的同时并等待获取其他线程的资源资源。
3.不可剥夺：线程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
4.环路等待：在发生死锁时，线程之间获取资源的顺序构成了环形链。

## 思路：
死锁的问题，即为有向图的环路检测问题。

死锁检测的流程可大致归纳为：
1. hook拦截系统的锁接口（pthread_mutex_lock和pthread_mutex_unlock）；
2. 在hook后的锁接口中，利用有向图存储资源分配图的信息。
    - 线程A申请线程B的资源锁：若锁未被占有，则占有这个锁（构建锁与线程关系）；若锁被占有，构建线程A指向线程B的申请边。
3. 创建一个线程，定时检测图进程是否有环的存在（dfs）。

1）加锁前：检测当前申请的锁是否被占用
    - 若被占用：构建当前线程指向占有锁的线程之间的申请边
    - 若未被占用：继续执行后续（占有这个锁）

2）加锁后：占有这个锁之后，检测
    - 该锁在之前没有被占有过：建立线程id与锁id的对应关系
    - 该锁在之前被占有过：释放之前创建的申请边，建立线程id与锁id的对应关系

3）释放锁：清除锁与线程的对应关系


## 工作原理
这个死锁检测组件通过钩子（hook）技术拦截 `pthread_mutex_lock` 和 `pthread_mutex_unlock` 函数调用，构建资源分配图并检测死锁。
1. 组件通过 `dlsym` 获取原始的 pthread 互斥锁函数
2. 重写 `pthread_mutex_lock` 和 `pthread_mutex_unlock` 函数
3. 在锁操作前后添加监控代码，构建资源分配图
4. 定期检查资源分配图中是否存在环（死锁）


## 使用方法
1. 拷贝源码，引入头文件 `deadlock_check.h`，
2. 调用：
    ```c
    init_hook();
    start_check();
    ```
3.编译源代码和死锁检测源码：
```bash
    gcc -o test test.c deadlock_check.c -ldl -lpthread
```
4. 运行程序：
```bash
    ./test
```





